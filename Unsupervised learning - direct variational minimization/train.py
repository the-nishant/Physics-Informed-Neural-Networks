# -*- coding: utf-8 -*-
"""Train .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kIKHnrefDyE1tmyvOPBQiYKAeeVpPNdg
"""

import matplotlib.pyplot as plt
from matplotlib import cm
import numpy as np
import sympy as sp
import os
import pickle 
from typing import Dict
import math

import idrlnet.shortcut as sc
import idrlnet.architecture.mlp as mlp
import idrlnet.net as net

"""# Brachistochrone curve

The Brachistochrone curve is a curve joining two given points $A$ and $B$ that takes the shortest time to travel from $A$ to $B$.

As a variational problem, it is equivalent to minimizing
$$
  T = \int_0^d \sqrt{\dfrac{1+(y')^2}{2gy}}dx,
$$
where $g$ is the gravitational constant and the horizontal distance between $A$ and $B$ is $d$.

For the sake of simplicity, we take $g = 1$.

## 1. IDRLnet package
"""

d = 1 # horizontal distance
h = 0.5 # height

x = sp.symbols('x')
y = sp.Function('y')(x)
geo = sc.Line1D(0, d)

@sc.datanode(sigma=1000.0)
class Boundary(sc.SampleDomain):
    def __init__(self):
        self.points = geo.sample_boundary(
            1,
        )
        self.constraints = {"y": -h*x/d}

    def sampling(self, *args, **kwargs):
        return self.points, self.constraints

@sc.datanode(loss_fn="L1")
class Interior(sc.SampleDomain):
    def sampling(self, *args, **kwargs):
        points = geo.sample_interior(10000)
        constraints = {
            "integral_dx": 0,
        }
        return points, constraints


@sc.datanode
class InteriorInfer(sc.SampleDomain):
    def __init__(self):
        self.points = sc.Variables()
        self.points["x"] = np.linspace(0, d, 1001, endpoint=True).reshape(-1, 1)
        self.points["area"] = np.ones_like(self.points["x"])

    def sampling(self, *args, **kwargs):
        return self.points, {}

class PlotReceiver(sc.Receiver):
    def __init__(self):
        xx = np.linspace(0, d, 1001, endpoint=True)
        self.xx = xx
        self.predict_history = []
    def receive_notify(self, obj: sc.Solver, message: Dict):
        if sc.Signal.SOLVE_START in message or (
            sc.Signal.TRAIN_PIPE_END in message and obj.global_step % 200 == 0
        ):
            points = s.infer_step({"InteriorInfer": ["x", "y"]})
            num_x = points["InteriorInfer"]["x"].detach().cpu().numpy().ravel()
            num_y = points["InteriorInfer"]["y"].detach().cpu().numpy().ravel()
            self.predict_history.append((num_y, obj.global_step))
            # print(self.predict_history)
        if sc.Signal.SOLVE_END in message:
            try:
                with open("result.pickle", "rb") as f:
                    self.predict_history = pickle.load(f)
            except:
                with open("result.pickle", "wb") as f:
                    pickle.dump(self.predict_history, f)
            for yy, step in self.predict_history:
                if step % 1000 == 0:
                    plt.plot(self.xx, yy, label=f"iter={step}")
                # if step == 400:
                #     plt.plot(self.xx, yy, label=f"iter={step}")
                # if step == 800:
                #     plt.plot(self.xx, yy, label=f"iter={step}")
                # if step == 1200:
                #     plt.plot(self.xx, yy, label=f"iter={step}")
                # if step == 1600:
                #     plt.plot(self.xx, yy, label=f"iter={step}")
                # if step == 2000:
                #     plt.plot(self.xx, yy, label=f"iter={step}")
                # if step == 2400:
                #     plt.plot(self.xx, yy, label=f"iter={step}")
                # if step == 2800:
                #     plt.plot(self.xx, yy, label=f"iter={step}")
                # if step == 3200:
                #     plt.plot(self.xx, yy, label=f"iter={step}")
                # if step == 1000:
                #     plt.plot(self.xx[::100], yy[::100], "-o")
            theta = np.linspace(0, 3.50837,100)
            plt.plot(0.2586 * (theta - np.sin(theta)), -0.2586 * (1 - np.cos(theta)), "-x", label = "exact")
            plt.legend()
            plt.xlabel("x")
            plt.ylabel("y")
            plt.savefig("iterations.png")
            plt.show()
            plt.close()

dx_exp = sc.ExpressionNode(expression=sp.sqrt((y.diff(x)) ** 2 + 1)/sp.sqrt(sp.Abs(y)), name='dx')
net = sc.get_net_node(inputs=("x",), outputs=("y",), name="net", arch=sc.Arch.mlp)
integral = sc.ICNode('dx', dim=1, time=False)

s = sc.Solver(
    sample_domains=(Boundary(), Interior(), InteriorInfer()),
    netnodes=[net],
    init_network_dirs=["pretrain_network_dir"],
    pdes=[
        dx_exp,
        integral,
    ],
    max_iter=10000,
)
s.register_receiver(PlotReceiver())
s.solve()

